version: 2

sources:
  - name: raw_banking            -- This is the nickname you'll use in dbt
    database: RAW_DB             -- Your actual Snowflake Database name
    schema: LANDING              -- Your actual Snowflake Schema name
    
    tables:
      - name: raw_accounts       -- The actual table name in Snowflake
        description: "Raw account data from core banking system"
        tests:
          - unique:
              column_name: account_id
          - not_null:
              column_name: account_id

      - name: raw_customers
        description: "Raw customer profile data"
        
      - name: raw_transactions
        description: "Immutable transaction ledger records"
        freshness:               -- dbt will alert you if data stops flowing!
          warn_after: {count: 24, period: hour}
          error_after: {count: 48, period: hour}
        loaded_at_field: transaction_date


# Now, instead of hardcoding a table name like SELECT * FROM RAW_DB.LANDING.RAW_ACCOUNTS, you would update your stg_banking_accounts.sql to use:

# -- Inside your staging model
# select * from {{ source('raw_banking', 'raw_accounts') }}
# Why this is important:
# Lineage: This creates the "green" starting nodes in your dbt lineage graph, showing exactly where your Data Vault starts.

# Environment Switching: If you move from DEV_DB to PROD_DB, you only have to change the database name in one place (this file) rather than in every single SQL model.

# Data Quality: You can add tests (like unique or not_null) directly to your raw data to catch issues before they hit your Data Vault.
