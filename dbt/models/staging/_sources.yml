version: 2

sources:
  - name: raw_banking
    database: RAW
    schema: BANKING
    description: "Raw banking data from S3"
    
    tables:
      - name: customers
        description: "Customer master data"
        columns:
          - name: customer_id
            description: "Unique customer identifier"
            tests:
              - not_null
              - unique
          - name: customer_name
          - name: email
          - name: created_at
          
      - name: accounts
        description: "Account master data"
        columns:
          - name: account_id
            tests:
              - not_null
              - unique
          - name: customer_id
            tests:
              - not_null
          - name: account_type
          - name: balance
          
      - name: transactions
        description: "Transaction records"
        freshness:
          warn_after: {count: 12, period: hour}
          error_after: {count: 24, period: hour}
        loaded_at_field: transaction_datetime


# Now, instead of hardcoding a table name like SELECT * FROM RAW_DB.LANDING.RAW_ACCOUNTS, you would update your stg_banking_accounts.sql to use:

# -- Inside your staging model
# select * from {{ source('raw_banking', 'raw_accounts') }}
# Why this is important:
# Lineage: This creates the "green" starting nodes in your dbt lineage graph, showing exactly where your Data Vault starts.

# Environment Switching: If you move from DEV_DB to PROD_DB, you only have to change the database name in one place (this file) rather than in every single SQL model.

# Data Quality: You can add tests (like unique or not_null) directly to your raw data to catch issues before they hit your Data Vault.
